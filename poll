src/main.cpp: 	data->poll = new struct pollfd[i]; // reservamos tantos polls como sockets haya
src/main.cpp:			data->poll[i].fd = sock_ptr->sock->s_fd; // asignamos el fd de cada socket a un poll
src/main.cpp:			data->poll[i].events = POLLIN; // ?
src/main.cpp:	data->fd_size = i;
src/main.cpp:	data->fd_count = i;
src/main.cpp:	data->poll = NULL;
src/main.cpp:	data->serv_list = NULL;
src/parse_config.cpp:			serv_back(&data->serv_list, serv_new()); // añadimos nuevo server creado
src/parse_config.cpp:			if (parse_element(serv_last(data->serv_list), line)) //parseamos la instrucción
src/poll.cpp:		int poll_count = poll(data->poll, data->fd_size, -1); // ?
src/poll.cpp:		for (int i = 0; i < data->fd_size; i++) // buscamos que socket esta listo para recibir cliente
src/poll.cpp:			if (data->poll[i].revents & POLLIN) // hay alguien listo para leer = hay un intento de conexion
src/poll.cpp:				//if (check_if_listener(data->poll[i].fd, list)) // comentamos de momento
src/poll.cpp:				c_fd = accept(data->poll[i].fd, (struct sockaddr *) &c_addr, &addrlen); // el cliente acepta el socket
src/poll.cpp:				//	add_pollfd(&data->poll, c_fd, &data->fd_count, &data->fd_size);
src/poll.cpp:				//	if (handle_client(data->poll[i].fd))
src/poll.cpp:				//		close(data->poll[i].fd);   /*cerramos fd y eliminamos de array pollfd*/
src/poll.cpp:				//		remove_pollfd(&data->poll, i, &data->fd_count); 
